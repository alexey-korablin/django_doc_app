def reference():
    """
    ПРОВЕРКА ВЕРСИИ django
    $ python -m django --version

    СОЗДАНИЕ ПРОЕКТА
    $ django-admin startproject <project_name>

    СТРУКТУРА
    mysite/
        manage.py
        mysite/
            __init__.py
            settings.py
            urls.py
            wsgi.py
    Каталог верхнего уровня - mysite - просто каталог, имя которого может быть изменено
    Файл manage.py - утилита командной строки для взаимодействия с django
    Внутренний каталог mysite/ - python-пакет для проекта. Это имя используется для импорта чего-либо из него.
        Например: mysite.urls
    mysite/__init__.py - пустой файл, говорящий python, что данный каталог является пакетом
    mysite/settings.py - файл для различных настроек проекта
    mysite/urls.py - содержит все пути используемые в проекте
    mysite/wsgi.py - точка входа для WSGI-совместимых вэб-серверов для обслуживания проекта

    ЗАПУСК СЕРВЕРА
    $ python manage.py runserver    --> команда запускает dev-сервер.
    Для смены порта выполняется команда     --> $ python manage.py runserver 8080
    Если же требуется сменить IP адрес сервера, нужно выполнить команду вот так:
        $ python manage.py runserver 0.0.0.0:8080
    Сервер перезапускает страницу автоматически почти во всех случаях изменения файлов, но при добавлении или удалении
        файлов перезапуск надо осуществлять вручную

    СОЗДАНИЕ ПРИЛОЖЕНИЯ
    Отличия приложения от проекта: приложение выполняет какое-то действие, например, предоставляет сервис. В то время
        как проект является набором различных настроек и приложений. В то же время приложение может быть частью
        нескольких проектов
    При создании приложения нужно находиться в одной директории с файлом manage.py
    Создание приложения выполняется командой: $ python manage.py startapp polls # polls - имя приложения
        Далее будет создана директория polls со следующими файлами и папками:
        polls/
            migrations/
                __init__.py
            __init__.py
            admin.py
            apps.py
            models.py
            tests.py
            views.py

    СОЗДАНИЕ VIEW
    Все представления создаются в файле views.py
    Для отображения какого-либо представления оно должно быть сопоставлено с каким-либо URL адресом. Делается это с
        помощью URLconf
    Чтобы создать URLconf в папке с приложением нужно создать файл urls.py
    Для того чтобы указать корень URLconf в файле urls.py (находится в корне проекта) нужно импортировать include и path
        из django.urls и добавить include() в список urlpatterns (см. файлы docsApp/urls.py и docsApp/polls/urls.py
        текущего проекта)
    Функция include() ищет сопоставления адресов, если находит, то отсекает сопоставленное и передает в URLconf
        оставшуюся строку для дальнейшей обработки. Смысл include() в легком подключении адресов
    Так как приложения имеют свои собственные настройки URL, в частности URLconf (polls/urls.py), они могут помещены за
        “/polls/”, или за “/fun_polls/”, или за “/content/polls/” и приложение все равно будет работать
    Функцию include() следует использовать при каждом добавлении адресов, исключение только admin.site.urls
    Функция path() принимает 4 аргумента: 2 обязательных и 2 опциональных. Обязательные: маршрут и представление.
        Опциональные: ключевые слова и имя.
    Аргумент path() route - является строкой, содержащей шаблон адреса. При запросе django обращается к массиву
        urlpatterns и сравнивает запрошенный адрес с шаблонами пока не найдет подходящий. Пример:
            имеется шаблон myapp/
            при запросах к адресам https://www.example.com/myapp/ и https://www.example.com/myapp/?page=3 результат
            будет одинаковым - myapp/
    Аргумент path() view - когда шаблон сопоставляется удачно, происходит вызов определенного представления с объектом
        HttpRequest в качестве первого аргумента и с прочими "захваченными" значениями в качестве второго аргумента
    Аргумент path() kwargs - ключевые слова могут быть переданы в качестве словаря к требуемому представлению
    Аргумент path() name - позволяет передать имя в качестве псевдонима для адреса. После чего к данному адресу можно
        будет не двусмысленно обратиться из любого места приложения.

    НАСТРОЙКА БАЗЫ ДАННЫХ
    Все настройки хранятся в файле settings.py
    Информация об используемой БД и пути к ее файлу находятся в константе DATABASES
    По умолчанию используется БД SQLite (не требует имени пользователя, пароля и хоста)
    Константа INSTALLED_APPS содержит все установленные приложения, которые должны быть доступны в django. По умолчанию
        установлены следующие приложения:
        * django.contrib.admin - управление сайтом
        * django.contrib.auth - система аутентификации
        * django.contrib.contenttypes - фреймворк для типов содержимого
        * django.contrib.sessions - фреймворк для работы с сессиями
        * django.contrib.messages - фреймворк для работы с сообщениями
        * django.contrib.staticfiles - фреймворк для работы со статическими файлами
    Чтобы приложение могло работать с базой данных нужно создать соответствующие записи. Делается это следующей
        командой: $ python manage.py migrate
        Команда migrate смотрит список INSTALLED_APPS и создает любые необходимые таблицы в БД в соответствии с
        настройками в файле mysite/settings.py

    СОЗДАНИЕ МОДЕЛИ
    Для создания таблицы в БД нужно создать модель. Модель создается в файле models.py, который находится в приложении.
        Модель представляет из себя python класс
    Каждая модель представляет из себя подкласс от django.db.models.Model
    Каждая модель содержит переменные, каждая из которых представляет запись из табицы БД в модели
    Каждое поле представлено экземпляром класса Field, например CharField (для текстового поля) или DateTimeField (для
        даты и времени). Благодаря этому django будет хранить типы данных для каждого поля
    Имя каждого экземпляра класса Fields является именем поля в БД
    Некоторые экземпляры класса Field  имеют обязательные аргументы, например CharField требует аргумент max_length. Это
        используется не только в схеме БД, но и при валидации
    Также могут быть определены и взаимоотношения, например через models.ForeignKey
    django поддерживает взаимоотношения: многие-к-одному, многие-ко-многим и один-к-одному

    АКТИВАЦИЯ МОДЕЛИ
    Для активации модели нужно сообщить проекту об установленном приложении.
    Для того чтобы включить приложение в проект нужно в INSTALLED_APPS указать на класс конфигурации этого приложения.
        Данный класс хранится в файле apps.py приложения. Так для приложения polls и его класса настроек PollsConfig
        путь будет выглядеть как polls.apps.PollsConfig. Подобную строку нужно добавить в файл settings.py проекта (в
        массив INSTALLED_APPS)
    Для выполнения миграции конкретного приложения (polls) в базу нужно сделать следующее:
        $ py manage.py makemigrations polls
    Команда makemigrations говорит о том, что были сделаны изменения в модели и их нужно сохранить как миграцию
    Миграции хранятся в папке migrations приложения. Данные миграции являются записями в БД и могут быть изменены
        вручную
    Схемой БД можно управлять и в автоматическом режиме, для этого существует команда migrate
    Посмотреть миграцию можно так: $ py manage.py sqlmigrate polls 0001
    Проверка приложения на наличие проблем: $ py manage.py check
    Добавление изменений в моделях: $ py manage.py migrate
    Flow:
        * сделать изменения в модели models.py
        * создать миграции для этих изменений $ py manage.py makemigrations
        * применить изменения в БД $ py manage.py migrate

    ВЗАИМОДЕЙСТВИЕ С API
    Чтобы запустить командную оболочку для взаимодействия с Django, нужно выполнить команду:
        $ python manage.py shell
    Для взаимодействия с объектами модели их нужно импортировать из polls/models.py:
        from polls.models import Question, Choice
    Для просмотра содержимого модели Question: Question.objects.all()   # --> <QuerySet []>
    Для создания нового запроса: q = Question(question_text="What's new?", pub_date=timezone.now()) # прежде
        импортировать timezone: from django.utils import timezone
    Сохранить запрос в БД: q.save() # после этого можно посмотреть доступные свойства объекта. Для объекта Question это
        id, question_text и pub_date
    Сохраненные значения могут быть изменены: q.question_text="what's up?"  # после снова необходимо выполнить q.save()
    Можно фильтровать записи, например по id: Question.objects.filter(id=2); или по текстовым вхождениям:
        Question.objects.filter(question_text__startswith="What") # --> <QuerySet [<Question: What's ip?>]>
    Если предполагается получить только одну запись, то можно использовать метод get, если же записей больше, то нужно
        использовать метод filter
    Записи можно получить по id или по primary key (pk), например: Question.objects.get(pk=1)
    Просмотр записей из смежного (related) объекта: q.choice_set.all() # --> <QuerySet []>
    Создание записей в смежном объекте: q.choice_set.create(choice_text='Not much', votes=0) # --> <Choice: Not much>
    Смежные объекты имеют доступ друг к другу. Если q = Question.objects.get(pk=1), то получить все записи смежного
        объекта Choice можно так: q.choice_set.all(), а количество записей так: q.choice_set.count()
    Чтобы получить доступ к свойствам смежного объекта нужно использовать "__":
        Choice.objects.filter(question__pub_date__year=current_year)    # получит все записи объекта Question c датой
        побликации, соответствующей current_year (current_year = timezone.now().year  == 2019)
    Чтобы удалить запись (можно и через смежный объект) нужно ее сначала получить:
        c = q.choice_set.filter(choice_text__startswith='Just') , а затем удалить: c.delete()   # -->
        (2, {'polls.Choice': 2}) - было удалено две записи

    АДМИНКА DJANGO
    Создание пользователя администратора $ python manage.py createsuperuser После ввода имени пользователя, пароля и
        подтверждения данных пользователь будет создан.
    Запуск development сервера: python manage.py runserver
    Для перехода в админку нужно перейти по адресу: http://127.0.0.1:8000/admin/
    В админке в разделе авторизации и аутентификации будут находиться 2 группы: Группы и Пользователи - эти группы
        предоставляются фреймворком django.contrib.auth
    Чтобы добавить приложение в админ. панель нужно зарегистрировать необходимые объекты в интерфейсе администратора.
        Для этого в файле manage.py каталога приложения нужно выполнить импорт модуля admin из django.contrib. Затем все
        необходимые объекты из модуля models приложения. После чего зарегистрировать эти объекты:
        from django.contrib import admin
        from .models import Question
        admin.site.register(Question)


    """

    pass
